#include <stdint.h>
#include <string.h>
#include <stdio.h>

#include "esp_bt.h"
#include "esp_gap_ble_api.h"
#include "esp_gattc_api.h"
#include "esp_gatt_defs.h"
#include "esp_bt_main.h"
#include "esp_gatt_common_api.h"
#include "freertos/FreeRTOS.h"

#include "esp_r1_api.h"

#define LOG_LOCAL_LEVEL ESP_LOG_INFO
#include "esp_log.h"

#define R1_SCAN_DURATION            (30U)   /* Scan duration in seconds */
#define R1_APP_ID                   (0U)

#define REPORT_CHAR_COUNT           (4U)
#define REPORT_PROFILE1             (0U)
#define REPORT_PROFILE2             (1U)
#define REPORT_PROFILE3             (2U)
#define REPORT_PROFILE4             (3U)

#define MODIFIER_NONE               (0U)
#define MODIFIER_RELATIVE           (1U)

/**
 * @brief Autogenerated R1 event names
 */
static const char *r1_event_name[] = {
#define X(name) #name,
R1_EVENTS_TABLE
#undef X
};

static const char *TAG = "R1";
static const char *remote_device_name = "ACGAM R1";

static esp_bd_addr_t gl_remote_bda;
static esp_gatt_if_t gl_gattc_if;
static uint16_t      gl_conn_id;

static bool gl_app_enabled = false;

/**
 * @brief Structure to decode each report characteristic
 */
typedef struct {
    uint8_t map_length;                 /*!< 'node' struct length.            */

    uint8_t profile_id;                 /*!< Report ID of report char.        */

    struct report_node {
        uint8_t modifiers;              /*!< Modifiers.                       */

        uint8_t bits;                   /*!< Bit-field size.                  */

        int8_t state;                   /*!< Previous state.                  */

        uint8_t id;                     /*!< ID of event coded within bf.     */

    } node[];                           /*!< Map node. Report char value
                                             consists of bit-fields. One
                                             structure instance describes one
                                             bit-field.                       */
} report_map_t;

/**
 * @brief Report characteristic structure
 */
typedef struct {
    uint16_t char_handle;               /*!< Report characteristic handle.    */

    uint16_t report_ref_descr_handle;   /*!< Report reference descriptor
                                             handle.                          */

    report_map_t *map;                  /*!< Map to decode report char value. */

} hid_report_char_t;

/**
 * @brief Static report char descriptions
 */
static hid_report_char_t gl_report[REPORT_CHAR_COUNT];

static report_map_t map_profile_1 = {
    .map_length = 11,
    .profile_id = 1,
    .node = {
        { .bits = 1, .id = R1_BUTTON1, },
        { .bits = 1, .id = R1_BUTTON2, },
        { .bits = 1, .id = R1_BUTTON3, },
        { .bits = 1, .id = R1_BUTTON1, },
        { .bits = 1, .id = R1_BUTTON2, },
        { .bits = 1, .id = R1_BUTTON3, },
        { .bits = 1, .id = R1_BUTTON4, },
        { .bits = 1, .id = R1_BUTTON5, },
        { .bits = 8, .id = R1_AXIS_X, .modifiers = MODIFIER_RELATIVE },
        { .bits = 8, .id = R1_AXIS_Y, .modifiers = MODIFIER_RELATIVE },
        { .bits = 8, .id = R1_WHEEL,  .modifiers = MODIFIER_RELATIVE },
    },
};

static report_map_t map_profile_2 = {
    .map_length = 7,
    .profile_id = 2,
    .node = {
        { .bits = 1, .id = R1_VOLUME_INCREMENT, },
        { .bits = 1, .id = R1_VOLUME_DECREMENT, },
        { .bits = 1, .id = R1_PLAY_PAUSE,       },
        { .bits = 1, .id = R1_MUTE,             },
        { .bits = 1, .id = R1_SCAN_PREV_TRACK,  },
        { .bits = 1, .id = R1_SCAN_NEXT_TRACK,  },
        { .bits = 1, .id = R1_AC_HOME,          },
    },
};

static report_map_t map_profile_4 = {
    .map_length = 14,
    .profile_id = 4,
    .node = {
        { .bits = 1, .id = R1_BUTTON1,  },
        { .bits = 1, .id = R1_BUTTON2,  },
        { .bits = 1, .id = R1_BUTTON3,  },
        { .bits = 1, .id = R1_BUTTON4,  },
        { .bits = 1, .id = R1_BUTTON5,  },
        { .bits = 1, .id = R1_BUTTON6,  },
        { .bits = 1, .id = R1_BUTTON7,  },
        { .bits = 1, .id = R1_BUTTON8,  },
        { .bits = 1, .id = R1_BUTTON9,  },
        { .bits = 1, .id = R1_BUTTON10, },
        { .bits = 1, .id = R1_BUTTON11, },
        { .bits = 1, .id = R1_BUTTON12, },
        { .bits = 2, .id = R1_AXIS_X, .state = 1,  },
        { .bits = 2, .id = R1_AXIS_Y, .state = 1,  },
    },
};

static report_map_t *gl_map[REPORT_CHAR_COUNT] = {
    [REPORT_PROFILE1] = &map_profile_1,
    [REPORT_PROFILE2] = &map_profile_2,
    [REPORT_PROFILE3] = NULL, /* Never used. */
    [REPORT_PROFILE4] = &map_profile_4,
};

static esp_ble_scan_params_t ble_scan_params = {
    .scan_type              = BLE_SCAN_TYPE_ACTIVE,
    .own_addr_type          = BLE_ADDR_TYPE_PUBLIC,
    .scan_filter_policy     = BLE_SCAN_FILTER_ALLOW_ALL,
    .scan_interval          = 0x1000,
    .scan_window            = 0x30,
    .scan_duplicate         = BLE_SCAN_DUPLICATE_DISABLE
};

static void
r1_pointer_process_event_default(esp_r1_pointer_data_t *data)
{
    ESP_LOGI(TAG, "pointer event: x is %d, y is %d, wheel is %d" \
                , data->x_axis, data->y_axis, data->wheel);
}
static esp_r1_pointer_cb_t gl_pointer_cb = r1_pointer_process_event_default;

static void
r1_keyboard_process_event_default(esp_r1_keyboard_data_t *data)
{
    ESP_LOGI(TAG, "keyboard event: %s in state %d"          \
                , r1_event_name[data->id], data->state);
}
static esp_r1_keyboard_cb_t gl_kbd_cb = r1_keyboard_process_event_default;

static void
r1_device_event_default(enum esp_r1_device_event_e event)
{
    switch (event) {
        case R1_EVENT_DISCONNECTED:
            ESP_LOGI(TAG, "device event: disconnected");
            break;

        case R1_EVENT_CONNECTED:
            ESP_LOGI(TAG, "device event: connected");
            break;
    }
}
static esp_r1_device_event_cb_t gl_dev_cb = r1_device_event_default;

static void
r1_gap_search_process(struct ble_scan_result_evt_param *scan_rst)
{
    uint8_t *adv_name = NULL;
    uint8_t adv_name_len = 0;

    /* Get a pointer to device name and find out data length */
    adv_name = esp_ble_resolve_adv_data( scan_rst->ble_adv         \
                                       , ESP_BLE_AD_TYPE_NAME_CMPL \
                                       , &adv_name_len);
    if (adv_name == NULL || adv_name_len == 0)
        return;

    char name[32];
    strncpy(name, (char *)adv_name, adv_name_len);

    /* Find device MAC-address to establish connection by device name */
    if (strstr(name, remote_device_name))
    {
        ESP_LOGI(TAG, "Magicsee R1 device is found; it's BDA is:");
        esp_log_buffer_hex(TAG, scan_rst->bda, ESP_BD_ADDR_LEN);

        /* Stop scanning and open virtual channels within all profiles */
        esp_ble_gap_stop_scanning();
        esp_ble_gattc_open( gl_gattc_if, scan_rst->bda    \
                          , scan_rst->ble_addr_type, true);
    }
    else
    {
        ESP_LOGI(TAG, "rssi: %d, name:", scan_rst->rssi);
        esp_log_buffer_char(TAG, adv_name, adv_name_len);
        ESP_LOGI(TAG, "bda:");
        esp_log_buffer_hex(TAG, scan_rst->bda, ESP_BD_ADDR_LEN);
    }
}

static void
r1_gap_cb(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param)
{
    switch (event) {

        /* Start scanning in case of successfully setting up scan params ------ */
        case ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT:
            esp_ble_gap_start_scanning(R1_SCAN_DURATION);
            break;

        /* Have no idea on reasons why would scan start fail, so just complain */
        case ESP_GAP_BLE_SCAN_START_COMPLETE_EVT:
            if (param->scan_start_cmpl.status != ESP_BT_STATUS_SUCCESS)
                ESP_LOGE(TAG, "scan start failed, error status = %x\n" \
                                       , param->scan_start_cmpl.status);
            break;

        /* Process scan result event ----------------------------------------- */
        case ESP_GAP_BLE_SCAN_RESULT_EVT:
            if (param->scan_rst.search_evt == ESP_GAP_SEARCH_INQ_RES_EVT)
                r1_gap_search_process(&param->scan_rst);

            if (param->scan_rst.search_evt == ESP_GAP_SEARCH_INQ_CMPL_EVT)
            {
                ESP_LOGD(TAG, "start scanning as SEARCH_INQ_CMPL_EVT");
                esp_ble_gap_start_scanning(R1_SCAN_DURATION);
            }
            break;

        /* Likewise the scan start event: just complain on error ------------- */
        case ESP_GAP_BLE_SCAN_STOP_COMPLETE_EVT:
            if (param->scan_stop_cmpl.status != ESP_BT_STATUS_SUCCESS)
                ESP_LOGE(TAG, "scan stop failed, error status = %x" \
                                     , param->scan_stop_cmpl.status);
            break;

        /* Output new connection params -------------------------------------- */
        case ESP_GAP_BLE_UPDATE_CONN_PARAMS_EVT:
            ESP_LOGI(TAG, "connection param update: status = %d, "      \
                          "min_int = %d, max_int = %d, conn_int = %d, " \
                          "latency = %d, timeout = %d"                  \
                        , param->update_conn_params.status              \
                        , param->update_conn_params.min_int             \
                        , param->update_conn_params.max_int             \
                        , param->update_conn_params.conn_int            \
                        , param->update_conn_params.latency             \
                        , param->update_conn_params.timeout);
            break;

        /* For debug purposes print all unhandled event codes ---------------- */
        default:
            ESP_LOGD(TAG, "r1_gap_cb called with event %d\n", event);
            break;
    }
}

static void
r1_register_for_notify(uint16_t char_handle, uint16_t descr_handle)
{
    /* Enable notifications on target device */
    uint8_t notify_en = 1;
    esp_ble_gattc_write_char_descr( gl_gattc_if                \
                                  , gl_conn_id                 \
                                  , descr_handle               \
                                  , sizeof(notify_en)          \
                                  , &notify_en                 \
                                  , ESP_GATT_WRITE_TYPE_NO_RSP \
                                  , ESP_GATT_AUTH_REQ_NONE);

    esp_ble_gattc_register_for_notify(gl_gattc_if, gl_remote_bda, char_handle);
}

static void
r1_search_result_process(struct gattc_search_res_evt_param *search_res)
{
    static esp_bt_uuid_t report_char_uuid = {
        .len = ESP_UUID_LEN_16,
        .uuid = { .uuid16 = ESP_GATT_UUID_HID_REPORT, },
    };

    static esp_bt_uuid_t ccc_desc_uuid = {
        .len = ESP_UUID_LEN_16,
        .uuid = { .uuid16 = ESP_GATT_UUID_CHAR_CLIENT_CONFIG, },
    };

    static esp_bt_uuid_t rpt_ref_desc_uuid = {
        .len = ESP_UUID_LEN_16,
        .uuid = { .uuid16 = ESP_GATT_UUID_RPT_REF_DESCR, },
    };

    esp_gattc_descr_elem_t descr_elem;
    esp_gattc_char_elem_t char_elem[REPORT_CHAR_COUNT];
    uint16_t count, descr_count, char_handle;
    esp_err_t status;

    /* Search for all 'report' chars */
    status = esp_ble_gattc_get_char_by_uuid( gl_gattc_if              \
                                           , gl_conn_id               \
                                           , search_res->start_handle \
                                           , search_res->end_handle   \
                                           , report_char_uuid         \
                                           , char_elem                \
                                           , &count);
    if (status != ESP_OK || count != REPORT_CHAR_COUNT)
    {
        ESP_LOGE(TAG, "report char isn't found: %d err id", status);
        return;
    }

   /* Iterate over each found char */
    while (count--)
    {
        char_handle = char_elem[count].char_handle;
        descr_count = 1;

        gl_report[count].char_handle = char_handle;

        /* Search for 'report ref' desc, used to get 'report' char info */
        status = esp_ble_gattc_get_descr_by_char_handle( gl_gattc_if       \
                                                       , gl_conn_id        \
                                                       , char_handle       \
                                                       , rpt_ref_desc_uuid \
                                                       , &descr_elem       \
                                                       , &descr_count);
        if (status != ESP_OK || descr_count != 1)
        {
            ESP_LOGE(TAG, "report ref desc isn't found");
            return;
        }
        gl_report[count].report_ref_descr_handle = descr_elem.handle;
        /* Read 'report id' for 'report' char */
        esp_ble_gattc_read_char_descr( gl_gattc_if            \
                                     , gl_conn_id             \
                                     , descr_elem.handle      \
                                     , ESP_GATT_AUTH_REQ_NONE);

        /* Search for 'ccc' desc, used to set notifications */
        status = esp_ble_gattc_get_descr_by_char_handle( gl_gattc_if   \
                                                       , gl_conn_id    \
                                                       , char_handle   \
                                                       , ccc_desc_uuid \
                                                       , &descr_elem   \
                                                       , &descr_count);
        if (status != ESP_OK || descr_count != 1)
        {
            ESP_LOGE(TAG, "ccc desc isn't found");
            return;
        }
        /* Register for notifications on 'report' char handle */
        r1_register_for_notify(char_handle, descr_elem.handle);
    }
}

static void
r1_notify_process(report_map_t *map, uint8_t *value, uint16_t value_len)
{
    ESP_LOGD(TAG, "notification is received: %d report id:", map->profile_id);
    ESP_LOG_BUFFER_HEX_LEVEL(TAG, value, value_len, ESP_LOG_DEBUG);

    esp_r1_pointer_data_t pointer_data = {0, };
    esp_r1_keyboard_data_t kbd_data = {0, };

    uint8_t byte_count, bit_count, mask, bits, is_pointer;
    int8_t state;
    int i;

    byte_count = 0;
    bit_count = 0;
    is_pointer = 0;
    for (i = 0; i < map->map_length; i++)
    {
        bits = map->node[i].bits;

        mask = (0xff >> (8 - bits)) << bit_count;
        state = (*(value + byte_count) & mask) >> bit_count;

        if (map->node[i].modifiers == MODIFIER_RELATIVE)
        {
                if (state != 0)
                {

                is_pointer = true;
                switch (map->node[i].id) {
                    case R1_AXIS_X:
                        pointer_data.x_axis = state;
                        break;

                    case R1_AXIS_Y:
                        pointer_data.y_axis = state;
                        break;

                    case R1_WHEEL:
                        pointer_data.wheel = state;
                        break;

                    default:
                        break;
                }
            }
        }
        else if (state != map->node[i].state)
        {
            map->node[i].state = state;

            kbd_data.id = map->node[i].id;
            kbd_data.state = state;

            gl_kbd_cb(&kbd_data);
        }

        bit_count += bits;

        byte_count += (bit_count / 8);
        bit_count %= 8;
    }

    if (is_pointer)
        gl_pointer_cb(&pointer_data);
}

static void
r1_gattc_cb(esp_gattc_cb_event_t event, esp_gatt_if_t gattc_if, esp_ble_gattc_cb_param_t *param)
{
    int i;

    switch (event) {

        /* Register event. It's done within 'esp_e1_init()' function to obtain
         * GATT interface ID ------------------------------------------------- */
        case ESP_GATTC_REG_EVT:
            ESP_LOGI(TAG, "application is registered: %04x if id" \
                        , gattc_if);
            gl_gattc_if = gattc_if;
            break;

        /* As physical connection is done store connection parameters -------- */
        case ESP_GATTC_CONNECT_EVT:
            ESP_LOGI(TAG, "connection is done: %04x connection id", gl_conn_id);

            gl_conn_id = param->connect.conn_id;
            memcpy(gl_remote_bda, param->connect.remote_bda, ESP_BD_ADDR_LEN);
            if (gl_dev_cb)
                gl_dev_cb(R1_EVENT_CONNECTED);
            break;

        /* Start service parsing after service discovery is complete --------- */
        case ESP_GATTC_DIS_SRVC_CMPL_EVT:
            esp_ble_gattc_search_service(gl_gattc_if, gl_conn_id, NULL);
            break;

        /* Process each search result with by calling corresponding to each
         * service UUID process function ------------------------------------- */
        case ESP_GATTC_SEARCH_RES_EVT:
            switch (param->search_res.srvc_id.uuid.uuid.uuid16) {

                case ESP_GATT_UUID_HID_SVC:
                    ESP_LOGD(TAG, "hid service is found: start %d and end %d" \
                                , param->search_res.start_handle              \
                                , param->search_res.end_handle);
                    r1_search_result_process(&param->search_res);
                    break;

                default:
                    ESP_LOGD(TAG, "%04x service is found"                    \
                                , param->search_res.srvc_id.uuid.uuid.uuid16);
                    break;
            }
            break;

        /* Nothing to be done on search complete event ----------------------- */
        case ESP_GATTC_SEARCH_CMPL_EVT:
            ESP_LOGD(TAG, "search is complete");
            break;

        /* Complain on error if registration for nofify has failed ----------- */
        case ESP_GATTC_REG_FOR_NOTIFY_EVT:
            if (param->reg_for_notify.status != ESP_GATT_OK)
                ESP_LOGW(TAG, "reg_for_notify event has failed: %d id" \
                            , param->reg_for_notify.status);
            break;

        /* Process each notify event ----------------------------------------- */
        case ESP_GATTC_NOTIFY_EVT:
            ESP_LOGD(TAG, "notify event has come: %d char handle" \
                        , param->notify.handle);
            for (i = 0; i < REPORT_CHAR_COUNT; i++)
            {
                if (param->notify.handle == gl_report[i].char_handle)
                    r1_notify_process(gl_report[i].map, param->notify.value  \
                                                      , param->notify.value_len);
            }
            break;

        /* Complain on error if descriptor write operation has failed -------- */
        case ESP_GATTC_WRITE_DESCR_EVT:
            if (param->write.status != ESP_GATT_OK)
                ESP_LOGW(TAG, "write desc has failed: %d err id" \
                            , param->write.status);
            break;

        /* Read 'report id' of each 'report' char and assign hardcoded static
         * map structure based on it ----------------------------------------- */
        case ESP_GATTC_READ_DESCR_EVT:
            for (i = 0; i < REPORT_CHAR_COUNT; i++)
            {
                if (param->read.handle == gl_report[i].report_ref_descr_handle)
                {
                    ESP_LOGD(TAG, "rpt ref desc is read: %04x id, %d handle" \
                                , param->read.value[0], param->read.handle);
                    gl_report[i].map = gl_map[param->read.value[0] - 1];
                }
            }
            break;

        /* Try to reconnect if application is enabled ------------------------ */
        case ESP_GATTC_DISCONNECT_EVT:
            ESP_LOGI(TAG, "device is disconnected");
            if (gl_app_enabled == true)
            {
                ESP_LOGI(TAG, "trying to reconnect");
                esp_ble_gap_set_scan_params(&ble_scan_params);
            }
            if (gl_dev_cb)
                gl_dev_cb(R1_EVENT_DISCONNECTED);
            break;

        /* For debug purposes print all unhandled event codes ---------------- */
        default:
            ESP_LOGD(TAG, "esp_gattc_cb called with %d", event);
            break;
    }
}

esp_err_t esp_r1_init(void)
{
    esp_err_t ret;

    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT));

    esp_bt_controller_config_t bt_config = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    ret = esp_bt_controller_init(&bt_config);
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG, "initialize controller failed: %s\n", esp_err_to_name(ret));
        return ret;
    }

    ret = esp_bt_controller_enable(ESP_BT_MODE_BLE);
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG, "enable controller failed: %s\n", esp_err_to_name(ret));
        return ret;
    }

    ret = esp_bluedroid_init();
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG, "init bluedroid stack failed: %s\n", esp_err_to_name(ret));
        return ret;
    }

    ret = esp_bluedroid_enable();
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG, "enable bluedroid stack failed: %s\n", esp_err_to_name(ret));
        return ret;
    }

    ret = esp_ble_gap_register_callback(r1_gap_cb);
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG, "gap register failed, error code = %x\n", ret);
        return ESP_FAIL;
    }

    ret = esp_ble_gattc_register_callback(r1_gattc_cb);
    if (ret != ESP_OK)
    {
        ESP_LOGE(TAG, "gattc register failed, error code = %x\n", ret);
        return ESP_FAIL;
    }

    esp_ble_gattc_app_register(0);

    ret = esp_ble_gatt_set_local_mtu(500);
    if (ret != ESP_OK)
        ESP_LOGW(TAG, "set local MTU failed, error code = %x\n", ret);

    return ESP_OK;
}

esp_err_t esp_r1_enable(void)
{
    gl_app_enabled = true;
    return (esp_ble_gap_set_scan_params(&ble_scan_params) ? ESP_FAIL : ESP_OK);
}

esp_err_t esp_r1_pointer_register_callback(esp_r1_pointer_cb_t cb)
{
    if (cb == NULL)
    {
        gl_pointer_cb = r1_pointer_process_event_default;
        return ESP_FAIL;
    }

    gl_pointer_cb = cb;
    return ESP_OK;
}

esp_err_t esp_r1_keyboard_register_callback(esp_r1_keyboard_cb_t cb)
{
    if (cb == NULL)
    {
        gl_kbd_cb = r1_keyboard_process_event_default;
        return ESP_FAIL;
    }

    gl_kbd_cb = cb;
    return ESP_OK;
}

esp_err_t esp_r1_device_event_register_callback(esp_r1_device_event_cb_t cb)
{
    if (cb == NULL)
    {
        gl_dev_cb = r1_device_event_default;
        return ESP_FAIL;
    }

    gl_dev_cb = cb;
    return ESP_OK;
}

const char* esp_r1_event_name_get_by_id(esp_r1_key_id_t id)
{
    return r1_event_name[id];
}
